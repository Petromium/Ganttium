/**
 * Cost Calculation Service
 * 
 * Handles automatic cost item generation from resource assignments.
 * Calculates planned and actual costs based on resource rates and pricing tiers.
 */

import { db } from "../db";
import { resources, resourceAssignments, costItems, tasks } from "../../shared/schema";
import { eq, and } from "drizzle-orm";
import { calculateTieredCost, PricingTier } from "./pricingTierService";
import type { Resource, ResourceAssignment, CostItem, Task } from "../../shared/schema";

/**
 * Calculate planned cost for a resource assignment
 * 
 * @param assignment - Resource assignment with effortHours
 * @param resource - Resource with rate and pricing tiers
 * @returns Planned cost amount
 */
export async function calculatePlannedCost(
  assignment: ResourceAssignment,
  resource: Resource
): Promise<number> {
  const effortHours = parseFloat(assignment.effortHours || "0");
  if (effortHours <= 0) {
    return 0;
  }

  const rate = parseFloat(resource.rate || "0");
  const tiers = resource.pricingTiers as PricingTier[] | null | undefined;
  const currency = resource.currency || "USD";

  const result = calculateTieredCost(effortHours, tiers, rate, currency);
  return result.totalCost;
}

/**
 * Calculate actual cost for a resource assignment
 * 
 * @param assignment - Resource assignment with actualHours
 * @param resource - Resource with rate and pricing tiers
 * @returns Actual cost amount
 */
export async function calculateActualCost(
  assignment: ResourceAssignment,
  resource: Resource
): Promise<number> {
  const actualHours = parseFloat(assignment.actualHours || "0");
  if (actualHours <= 0) {
    return 0;
  }

  const rate = parseFloat(resource.rate || "0");
  const tiers = resource.pricingTiers as PricingTier[] | null | undefined;
  const currency = resource.currency || "USD";

  const result = calculateTieredCost(actualHours, tiers, rate, currency);
  return result.totalCost;
}

/**
 * Auto-generate cost item from resource assignment
 * 
 * @param assignmentId - Resource assignment ID
 * @param userId - User ID creating the cost item
 * @returns Created cost item or null if assignment not found
 */
export async function autoGenerateCostItem(
  assignmentId: number,
  userId: string
): Promise<CostItem | null> {
  // Fetch assignment with related resource and task
  const [assignment] = await db
    .select()
    .from(resourceAssignments)
    .where(eq(resourceAssignments.id, assignmentId))
    .limit(1);

  if (!assignment) {
    return null;
  }

  const [resource] = await db
    .select()
    .from(resources)
    .where(eq(resources.id, assignment.resourceId))
    .limit(1);

  if (!resource) {
    return null;
  }

  const [task] = await db
    .select()
    .from(tasks)
    .where(eq(tasks.id, assignment.taskId))
    .limit(1);

  if (!task) {
    return null;
  }

  // Calculate planned cost
  const plannedCost = await calculatePlannedCost(assignment, resource);
  const actualCost = await calculateActualCost(assignment, resource);

  // Determine category based on resource type
  let category = "labor";
  if (resource.type === "equipment") {
    category = "equipment";
  } else if (resource.type === "material") {
    category = "materials";
  }

  // Create cost item
  const [costItem] = await db
    .insert(costItems)
    .values({
      projectId: task.projectId,
      taskId: task.id,
      resourceAssignmentId: assignmentId,
      category,
      description: `${resource.name} - ${task.name}`,
      budgeted: plannedCost.toString(),
      actual: actualCost.toString(),
      currency: resource.currency || "USD",
      status: "planned",
      autoGenerated: true,
      date: new Date(),
    })
    .returning();

  return costItem;
}

/**
 * Update cost item when resource assignment changes
 * 
 * @param assignmentId - Resource assignment ID
 * @param userId - User ID updating the cost item
 * @returns Updated cost item or null if not found
 */
export async function updateAutoGeneratedCostItem(
  assignmentId: number,
  userId: string
): Promise<CostItem | null> {
  // Find existing auto-generated cost item for this assignment
  const [existingCostItem] = await db
    .select()
    .from(costItems)
    .where(
      and(
        eq(costItems.resourceAssignmentId, assignmentId),
        eq(costItems.autoGenerated, true)
      )
    )
    .limit(1);

  if (!existingCostItem) {
    // Create new one if doesn't exist
    return await autoGenerateCostItem(assignmentId, userId);
  }

  // Fetch assignment and resource
  const [assignment] = await db
    .select()
    .from(resourceAssignments)
    .where(eq(resourceAssignments.id, assignmentId))
    .limit(1);

  if (!assignment) {
    return null;
  }

  const [resource] = await db
    .select()
    .from(resources)
    .where(eq(resources.id, assignment.resourceId))
    .limit(1);

  if (!resource) {
    return null;
  }

  // Recalculate costs
  const plannedCost = await calculatePlannedCost(assignment, resource);
  const actualCost = await calculateActualCost(assignment, resource);

  // Update cost item
  const [updatedCostItem] = await db
    .update(costItems)
    .set({
      budgeted: plannedCost.toString(),
      actual: actualCost.toString(),
      updatedAt: new Date(),
    })
    .where(eq(costItems.id, existingCostItem.id))
    .returning();

  return updatedCostItem;
}

/**
 * Sync all auto-generated cost items for a task
 * 
 * @param taskId - Task ID
 * @param userId - User ID performing the sync
 */
export async function syncTaskCostItems(taskId: number, userId: string): Promise<void> {
  const assignments = await db
    .select()
    .from(resourceAssignments)
    .where(eq(resourceAssignments.taskId, taskId));

  for (const assignment of assignments) {
    await updateAutoGeneratedCostItem(assignment.id, userId);
  }
}

/**
 * Sync all auto-generated cost items for a project
 * 
 * @param projectId - Project ID
 * @param userId - User ID performing the sync
 */
export async function syncProjectCostItems(projectId: number, userId: string): Promise<void> {
  const projectTasks = await db
    .select({ id: tasks.id })
    .from(tasks)
    .where(eq(tasks.projectId, projectId));

  for (const task of projectTasks) {
    await syncTaskCostItems(task.id, userId);
  }
}

